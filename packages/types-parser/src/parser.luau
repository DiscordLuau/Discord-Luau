local FileSystem = require("@std-polyfills/filesystem")

local Moonwave = require("@types-parser/moonwave")
local Tags = require("@types-parser/tags")

local MoonwaveTypes = require("@types/moonwaveTypes")

local FILE_HEADER = [=[--[[
	THIS FILE WAS AUTOGENERATED BY THE @types-parser/ PACKAGE;

	modifications to this file may be overwritten when the package is updated.
]]]=]

local Parser = {}

function Parser.fileNameFromPath(path: string)
	local pathSplit = string.split(path, "/")
	local fileName = pathSplit[#pathSplit]

	if string.sub(fileName, -1) == "s" then
		fileName = string.sub(fileName, 1, #fileName - 1)
	end

	return `{fileName}Types.luau`
end

function Parser.fileContentFromMoonwaveExport(moonwaveData: MoonwaveTypes.MoonwaveDataExportArray)
	local fileContent = FILE_HEADER

	local requiredModules: { string } = {}
	local generatedClasses: { string } = {}

	local function getMoonwaveEntryForClass(class: string): MoonwaveTypes.MoonwaveData?
		for _, packageObject in moonwaveData do
			if packageObject.name == class then
				return packageObject
			end
		end

		return
	end

	local function getSafeTypeForClass(class: string)
		local packageObject = getMoonwaveEntryForClass(class)

		assert(packageObject, `Expected moonwave data for class '{class}'`)

		local module, class = string.match(packageObject.name, "(%S+)%.(%S+)")
		local tags = Tags.getTags(packageObject)
		local classTyped = `{class}`

		if tags.generics then
			classTyped = `{class}<{table.concat(tags.generics, ", ")}>`
		end

		return classTyped
	end

	for _, packageObject in moonwaveData do
		local module, class = string.match(packageObject.name, "(%S+)%.(%S+)")

		local classTyped = getSafeTypeForClass(packageObject.name)

		local moduleProperties: { string } = {}
		local moduleFunctions: { string } = {}
		local moduleMethods: { string } = {}

		local function parseLuaType(luaType: string)
			local targetModule, targetClass = string.match(luaType, "(%a+)%.(%a+)")

			if targetModule and targetClass then
				if targetModule == module then
					if targetClass == class then
						return classTyped
					else
						return targetClass
					end
				else
					table.insert(requiredModules, targetModule)

					return getSafeTypeForClass(luaType) 
				end
			end

			return luaType
		end

		if packageObject.properties then
			for _, property in packageObject.properties do
				local propertyType = parseLuaType(property.lua_type)
				local propertyName = property.name

				table.insert(moduleProperties, `{propertyName}: {propertyType}`)
			end
		end

		if packageObject.functions then
			for _, prototype in packageObject.functions do
				local functionName = prototype.name
				local functionParameters: { string } = {}
				local functionReturns: { string } = {}

				if prototype.params then
					for _, parameter in prototype.params do
						table.insert(functionParameters, parseLuaType(parameter.lua_type))
					end
				end

				if prototype.returns then
					for _, returned in prototype.returns do
						table.insert(functionReturns, parseLuaType(returned.lua_type))
					end
				end

				if prototype.function_type == "method" then
					table.insert(
						moduleMethods,
						`{functionName}: ({classTyped}{#functionParameters > 0 and ", " or ""}{table.concat(
							functionParameters,
							", "
						)}) -> ({table.concat(functionReturns, ", ")})`
					)
				else
					table.insert(
						moduleFunctions,
						`{functionName}: ({table.concat(functionParameters, ", ")}) -> ({table.concat(
							functionReturns,
							", "
						)})`
					)
				end
			end
		end

		table.insert(generatedClasses, `export type {classTyped} = \{{
			`{#moduleProperties > 0 and `{
				`\n\t-- [[ CLASS FUNCTIONS ]] --\n` ..
				`\t{string.gsub(table.concat(moduleProperties, ", \n"), "\n", "\n\t")},`
			}` or ""}`
		} {#moduleProperties > 0 and `\n` or ` `}}& \{{
			`{#moduleFunctions > 0 and `{
				`\n\t-- [[ CLASS FUNCTIONS ]] --\n` ..
				`\t{string.gsub(table.concat(moduleFunctions, ", \n"), "\n", "\n\t")},`
			}` or ""}` .. 

			`{#moduleMethods > 0 and `{
				`{#moduleFunctions > 0 and `\n` or ``}` ..

				`\n\t-- [[ CLASS METHODS ]] --\n` ..
				`\t{string.gsub(table.concat(moduleMethods, ", \n"), "\n", "\n\t")}`
			}` or ""}`
		}\n}`)
	end

	if #requiredModules > 0 then
		fileContent ..= `\n\n-- [[ REQUIRED MODULES ]] --\n`
		for _, requiredModule in requiredModules do 
			fileContent ..= `local {requiredModule} = require("@types/{requiredModule}")\n`
		end
	end
	
	fileContent ..= `\n\n-- [[ GENERATED CLASSES ]] --\n`
	for _, typedClass in generatedClasses do 
		fileContent ..= typedClass .. `\n\n`
	end

	fileContent ..= `-- [[ MODULE RETURN ]] --\n`
	fileContent ..= `return "GENERATED_TYPES_FILE"\n`

	return fileContent
end

function Parser.parse(path: string)
	local moonwaveData = Moonwave.extractCommentsIntoJson(path)

	local fileName = Parser.fileNameFromPath(path)
	local fileContent = Parser.fileContentFromMoonwaveExport(moonwaveData)

	FileSystem.writeFile(`packages/types/src/{fileName}`, fileContent)
end

return Parser
